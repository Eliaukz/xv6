# 三周目

## 内核优化

内核优化有各种各样的方式，包括并行，异步，cache访存等等。  

## 写时复制 COW

这里讨论的是fork时的优化，[写时复制（COW）](https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD)
  
Copy-on-write适用于读多写少的情况，最大程度的提高读的效率，  

如果fork后紧接着exec操作，则会丢弃原有的进程空间，这里的优化可以减少这种fork产生进程空间后抛弃全部进程空间的情况。

在riscv中，保留了2位标记位，我们可以利用这实现一个标记COW的位。

然后需要实现页表的引用计数，表示有该页表被几个进程同时访问，只有该页表的引用计数为0时，才可以被free掉，否则在调用free时，仅仅将引用计数减一。

而这里为了保证共享变量的互斥访问，我们需要使用到[锁](./四周目.md)。


###  页面计数器 

分析xv6地址空间不难得知，页表位于KERNBASE和TPYSTOP之间，大小是PGSIZE，因此我们可以计算出页表的数量。

这里我选择了char型数组记录数量主要考虑到可以节省一下内存空间（not sure）。

```c
#define NPAGES ((PHYSTOP - KERNBASE) / PGSIZE)
struct {
  struct spinlock lock;
  struct run *freelist;
  char count[NPAGES];
} kmem;
```

而对于给定的pa，计算其位于的页表的下标就很容易实现`(pa - KERNBASE) / PGSIZE`，即使pa未对齐，也可以通过下取整的方式自动“对齐”。

### 缺页中断

这里在处理中断时要考虑是否cow引起的中断，具体在缺页异常时，如果是读写错误，就有可能是因为cow引起，因此需要我们判断是否需要分配新页，这部分代码参考[vm.c](../kernel/vm.c)中的`memcopy()`实现。


## 懒分配Lazy allocation

~~以前的实验要求实现一个懒分配的优化策略，因此这里挖坑了，以后来填~~

TODO






